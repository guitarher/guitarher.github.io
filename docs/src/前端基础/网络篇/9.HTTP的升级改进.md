<script setup>
  import img from '/imgs/前端基础/spdy.png'
  import img1 from '/imgs/前端基础/http2-frame.png'
  import img2 from '/imgs/前端基础/http2基本概念.png'
  import img3 from '/imgs/前端基础/http2基本概念1.png'
  import img4 from '/imgs/前端基础/多路复用.png'
  import img5 from '/imgs/前端基础/优先级.png'
  import img6 from '/imgs/前端基础/头部压缩.png'
  import img7 from '/imgs/前端基础/服务器推送.png'
  import img8 from '/imgs/前端基础/握手延迟.png'
  import img9 from '/imgs/前端基础/握手延迟1.png'
  import img10 from '/imgs/前端基础/http3.png'
  import img11 from '/imgs/前端基础/tls连接9.png'
  import img12 from '/imgs/前端基础/tls连接10.png'
</script>

# HTTP的升级改进

## HTTP协议的不足（HTTP/1.1）

- 同一时间，一个连接只能对应一个请求
- 针对同一个域名，大多数浏览器允许同时最多6个并发连接
- 只允许客户端主动发起请求
- 一个请求只能对应一个响应
- 同一个会话的多次请求中，头信息会被重复传输
  - 通常会给每个传输增加500~800字节的开销
  - 如果使用 Cookie，增加的开销有时会达到上千字节

## SPDY

- SPDY（speedy的缩写），是基于TCP的应用层协议，它强制要求使用SSL/TLS
- 2009年11月，Google宣布将SPDY作为提高网络速度的内部项目
- SPDY与HTTP的关系
  - SPDY并不用于取代HTTP，它只是修改了HTTP请求与响应的传输方式
  - 只需增加一个SPDY层，现有的所有服务端应用均不用做任何修改
  - SPDY是HTTP/2的前身
  - 2015年9月，Google宣布移除对SPDY的支持，拥抱HTTP/2
<img :src="img"/>

## HTTP/2

- HTTP/2，于2015年5月以RFC 7540正式发表
- 根据W3Techs的数据，截至2019年6月，全球有36.5%的网站支持了HTTP/2
- HTTP/1.1和HTTP/2速度对比
  - [http://www.http2demo.io/](https://http2.akamai.com/demo)
- HTTP/2在底层传输做了很多的改进和优化，但在语意上完全与HTTP/1.1兼容
  - 比如请求方法（如GET、POST）、Status Code、各种Headers等都没有改变
  - 因此，要想升级到HTTP/2
    - 开发者不需要修改任何代码
    - 只需要升级服务器配置、升级浏览器

### HTTP/2的特性——二进制格式

- HTTP/2采用二进制格式传输数据，而非HTTP/1.1的文本格式
- 二进制格式在协议的解析和优化扩展上带来更多的优势和可能
<img :src="img1"/>

### HTTP/2 一些基本概念

- 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息
  - 所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向数据流
- 消息：与逻辑HTTP请求或响应消息对应，由一系列帧组成
- 帧：HTTP/2通信的最小单位，每个帧都包含帧头（会标识出当前帧所属的数据流）
  - 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装
<img :src="img2"/>
<img :src="img3"/>

### HTTP/2的特性 - 多路复用 (Multiplexing)

- 客户端和服务器可以将 HTTP消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来
- 并行交错地发送多个请求，请求之间互不影响
- 并行交错地发送多个响应，响应之间互不干扰
- 使用一个连接并行发送多个请求和响应
- 不必再为绕过HTTP/1.1限制而做很多工作
  - 比如image sprites、合并CSS\JS、内嵌CSS\JS\Base64图片、域名分片等
<img :src="img4"/>

### HTTP/2的特性 — 优先级

- HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系
  - 可以向每个数据流分配一个介于1至256之间的整数
  - 每个数据流与其他数据流之间可以存在显式依赖关系
- 客户端可以构建和传递“优先级树”，表明它倾向于如何接收响应
- 服务器可以使用此信息通过控制CPU、内存和其他资源的分配设定数据流处理的优先级
  - 在资源数据可用之后，确保将高优先级响应以最优方式传输至客户端
<img :src="img5"/>

- 应尽可能先给父数据流分配资源
- 同级数据流（共享相同父项）应按其权重比例分配资源
  - ①A、B依赖于隐式“根数据流”，A获得的资源比例是12/16，B获得的资源比例是4/16
  - ②D依赖于根数据流，C依赖于D，D应先于C获得完整资源分配
  - ③D应先于C获得完整资源分配，C应先于A和B获得完整资源分配，B获得的资源是A所获资源的1/3
  - ④D应先于E和C获得完整资源分配，E和C应先于A和B获得相同的资源分配，B获得的资源是A所获资源的1/3

### HTTP/2的特性 - 头部压缩

- HTTP/2使用HPACK压缩请求头和响应头
  - 可以极大减少头部开销，进而提高性能
  - 早期版本的HTTP/2和SPDY使用 zlib压缩
    - 可以将所传输头数据的大小减小85%~88%
    - 但在2012年夏天，被攻击导致会话劫持
    - 后被更安全的HPACK取代
<img :src="img6"/>

### HTTP/2的特性 – 服务器推送 (Server Push)

- 服务器可以对一个客户端请求发送多个响应
  - 除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端额外明确地请求
<img :src="img7"/>

## HTTP/2的问题 - 队头阻塞 (head of line blocking)

- HTTP/2仍然存在TCP层的队头阻塞问题
- QUIC协议通过基于UDP的传输层解决了这个问题

## HTTP/2的问题 – 握手延迟

- RTT（Round Trip Time）：往返时延，可以简单理解为通信一来一回的时间
- TCP + TLS的握手延迟较高，尤其是在重复连接或首次连接时
- QUIC协议通过减少握手延迟来提升性能
<img :src="img8"/>
<img :src="img9"/>

## HTTP/3

- HTTP/3由Google开发，弃用TCP协议，改为使用基于UDP协议的QUIC协议实现
- QUIC（Quick UDP Internet Connections），译为：快速UDP网络连接，由Google开发，在2013年实现
- 于2018年从HTTP-over-QUIC改为HTTP/3
<img :src="img10"/>

### HTTP/3 一 疑问

- HTTP/3基于UDP，如何保证可靠传输？
  - 由QUIC来保证
- 为何Google不开发一个新的不同于TCP、UDP的传输层协议？
  - 目前世界上的网络设备基本只认TCP、UDP
  - 如果要修改传输层，意味着操作系统的内核也要修改
  - 另外，由IETF标准化的许多TCP新特性都因缺乏广泛支持而没有得到广泛的部署或使用
  - 因此，要想开发并应用一个新的传输层协议，是极其困难的一件事情

### HTTP/3的特性 — 连接迁移

- QUIC的连接不受4要素的影响，当4要素发生变化时，原连接依然维持
- QUIC连接不以4要素作为标识，而是使用一组Connection ID（连接ID）来标识一个连接
  - 即使IP或者端口发生变化，只要Connection ID没有变化，那么连接依然可以维持
  - 比如
    - 当设备连接到Wi-Fi时，将进行中的下载从蜂窝网络连接转移到更快速的Wi-Fi连接
    - 当Wi-Fi连接不再可用时，将连接转移到蜂窝网络连接

### HTTP/3的问题 — 操作系统内核、CPU负载

- 据Google和Facebook称，与基于TLS的HTTP/2相比，它们大规模部署的QUIC需要近2倍的CPU使用量
- Linux内核的UDP部分没有得到像TCP那样的优化，因为传统上没有使用UDP进行如此高速的信息传输
- TCP和TLS有硬件加速，而这对于UDP很罕见，对于QUIC则基本不存在
- 随着时间的推移，相信这个问题会逐步得到改善
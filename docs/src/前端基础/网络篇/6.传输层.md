<script setup>
  import img from '/imgs/前端基础/tcp-udp.png'
  import img1 from '/imgs/前端基础/udp.png'
  import img2 from '/imgs/前端基础/udp-校验和.png'
  import img3 from '/imgs/前端基础/tcp数据格式.png'
  import img4 from '/imgs/前端基础/tcp检验和.png'
  import img5 from '/imgs/前端基础/tcp可靠传输.png'
  import img6 from '/imgs/前端基础/tcp可靠传输1.png'
  import img7 from '/imgs/前端基础/连续arq和滑动窗口.png'
  import img8 from '/imgs/前端基础/sack.png'
  import img9 from '/imgs/前端基础/拥塞控制.png'
  import img10 from '/imgs/前端基础/慢开始.png'
  import img11 from '/imgs/前端基础/慢开始1.png'
  import img12 from '/imgs/前端基础/拥塞避免.png'
  import img13 from '/imgs/前端基础/快重传.png'
  import img14 from '/imgs/前端基础/快重传+快恢复.png'
  import img15 from '/imgs/前端基础/序号、确认号.png'
</script>






## 传输层（Transport）

- 传输层有2个协议
  - TCP（Transmission Control Protocol），传输控制协议
  - UDP（User Datagram Protocol），用户数据报协议

<img :src="img"/>

## UDP 数据格式

- UDP是无连接的，减少了建立和释放连接的开销。
- UDP尽最大能力交付，不保证可靠交付。
- 首部只有8个字节（TCP的首部至少20个字节）。
- UDP长度（Length）
  - 占16位，首部的长度+ 数据的长度

<img :src="img1"/>

## UDP 检验和 (Checksum)

- 检验和的计算内容：伪首部 + 首部 + 数据。
- 伪首部：仅在计算检验和时起作用，并不会传递给网络层。

<img :src="img2"/>

## 端口（Port）

- UDP首部中端口占用2字节，取值范围是0~65535。
- 客户端的源端口是临时开启的随机端口。
- 防火墙可以设置开启/关闭某些端口来提高安全性。

### 常用命令行
- `netstat -an`：查看被占用的端口。
- `netstat -anb`：查看被占用的端口、占用端口的应用程序。
- `telnet 主机 端口`：查看是否可以访问主机的某个端口。

### 常见协议默认端口号
| 协议  | 默认端口号   |
| ----- | ------------ |
| HTTP  | TCP + 80     |
| HTTPS | TCP + 443    |
| FTP   | TCP + 21     |
| MySQL | TCP + 3306   |
| DNS   | UDP\TCP + 53 |
| SMTP  | TCP + 25     |
| POP3  | TCP + 110    |

## TCP 数据格式

- **数据偏移**：占4位，取值范围是0x0101~0x1111，乘以4为首部长度（Header Length），首部长度是20~60字节。
- **保留**：占6位，目前全为0。

<img :src="img3"/>

## TCP 检验和 (Checksum)

- 跟UDP一样，TCP检验和的计算内容：伪首部 + 首部 + 数据。
- 伪首部：占用12字节，仅在计算检验和时起作用，并不会传递给网络层。

<img :src="img4"/>

## TCP 标志位（Flags）
- **URG（Urgent）**：当URG=1时，紧急指针字段才有效，表明当前报文段中有紧急数据，应优先尽快传送。
- **ACK（Acknowledgment）**：当ACK=1时，确认号字段才有效。
- **PSH（Push）**：当PSH=1时，接收方应尽快将数据交给应用层。
- **RST（Reset）**：当RST=1时，表明连接中出现严重差错，必须释放连接，然后再重新建立连接。
- **SYN（Synchronization）**：当SYN=1、ACK=0时，表明这是一个建立连接的请求。若对方同意建立连接，则回复SYN=1、ACK=1。
- **FIN（Finish）**：当FIN=1时，表明数据已经发送完毕，要求释放连接。

## TCP 序号、确认号、窗口
- **序号（Sequence Number）**：占4字节，传输过程的每一个字节都会有一个编号，建立连接后，序号代表这一次传给对方的TCP数据部分的一个字节的编号。
- **确认号（Acknowledgment Number）**：占4字节，建立连接后，确认号代表期望对方下一次传过来的TCP数据部分的一个字节的编号。
- **窗口（Window）**：占2字节，用于流量控制，告知对方下一次允许发送的数据大小（字节为单位）。

## TCP的要点

- 可靠传输
- 流量控制
- 拥塞控制
- 连接管理
  - 建立连接
  - 释放连接

## TCP 可靠传输
- **停止等待ARQ协议**：发送一个分组就停止发送等待确认。

  <img :src="img5"/>

  <img :src="img6"/>

- 若有个包重传了N次还是失败，会一直持续重传到成功为止么？

  - 这个取决于系统的设置，比如有些系统，重传5次还未成功就会发送reset报文（RST）断开TCP连接

- **连续ARQ协议 + 滑动窗口协议**：发送窗口中的分组连续发送，发送完后，停止等待确认。

- 如果接收窗口最多能接收4个包，但发送方只发了2个包，接收方如何确定后面还有没有2个包？

  - 等待一定时间后没有第3个包，就会返回确认收到2个包给发送方

<img :src="img7"/>

### SACK（选择性确认）

- 在TCP通信过程中，如果发送序列中间某个数据包丢失（比如1、2、3、4、5中的3丢失了）

- TCP会通过重传最后确认的分组后续的分组（最后确认的是2，会重传3、4、5）

- 这样原先已经正确传输的分组也可能重复发送（比如4、5），降低了TCP性能

- 为改善上述情况，发展出了SACK（Selective acknowledgment，选择性确认）技术

  - 告诉发送方哪些数据丢失，哪些数据已经提前收到
  - 使TCP只重新发送丢失的包（比如3），不用发送后续所有的分组（比如4、5）

- SACK信息会放在TCP首部的选项部分

  - Kind：占1字节。值为5代表这是SACK选项
  - Length：占1字节。表明SACK选项一共占用多少字节
  - Left Edge：占4字节，左边界
  - Right Edge：占4字节，右边界

<img :src="img8"/>

## 为什么选择在传输层就将数据“大卸八块”分成多个段，而不是等到网络层再分片传递给数据链路层？

- 因为可以提高重传的性能

- 需要明确的是：可靠传输是在传输层进行控制的
  - 如果在传输层不分段，一旦出现数据丢失，整个传输层的数据都得重传
  - 如果在传输层分了段，一旦出现数据丢失，只需要重传丢失的那些段即可

## TCP 流量控制
- 如果接收方的缓存区满了，发送方还在疯狂着发送数据

  - 接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源

  - 所以要进行流量控制

- 什么是流量控制？

  - 让发送方的发送速率不要太快，让接收方来得及接收处理

- **原理**

  - 通过确认报文中窗口字段来控制发送方的发送速率。

  - 发送方的发送窗口大小不能超过接收方给出的窗口大小。

  - 当发送方收到接收窗口的大小为0时，发送方就会停止发送数据。

### 特殊情况

- 一开始，接收方给发送方发送了0窗口的报文段

- 后面，接收方又有了一些存储空间，给发送方发送的非0窗口的报文段丢失了

- 发送方的发送窗口一直为零，双方陷入僵局

### 解决方案

- 当发送方收到0窗口通知时，这时发送方停止发送报文

- 并且同时开启一个定时器，隔一段时间就发个测试报文去询问接收方最新的窗口大小

- 如果接收的窗口大小还是为0，则发送方再次刷新启动定时器

## TCP 拥塞控制

### 介绍

- 拥塞控制
  - 防止过多的数据注入到网络中
  - 避免网络中的路由器或链路过载

- 拥塞控制是一个全局性的过程
  - 涉及到所有的主机、路由器
  - 以及与降低网络传输性能有关的所有因素
  - 是大家共同努力的结果

- 相比而言，流量控制是点对点通信的控制

<img :src="img9"/>

### 方法

- **慢开始（slow start）**：CWnd的初始值比较小，随着数据包被接收方确认，CWnd成倍增长（指数级）。
- **拥塞避免（congestion avoidance）**：当CWnd达到慢开始阈值后，以线性方式增加。
- **快速重传（fast retransmit）**：当发送方连续收到三个重复确认，立即重传对方尚未收到的报文段。
- **快速恢复（fast recovery）**：当发送方连续收到三个重复确认，执行“乘法减小”算法，把ssthresh减为拥塞峰值的一半，然后开始执行拥塞避免算法。

### 慢开始



## TCP 建立连接 - 3次握手
1. **第一次握手**：客户端发送SYN=1, ACK=0, seq=x。
2. **第二次握手**：服务器发送SYN=1, ACK=1, seq=y, ack=x+1。
3. **第三次握手**：客户端发送ACK=1, seq=x+1, ack=y+1。

## TCP 释放连接 - 4次挥手
1. **第一次挥手**：客户端发送FIN=1, ACK=1, seq=u, ack=v。
2. **第二次挥手**：服务器发送ACK=1, seq=v, ack=u+1。
3. **第三次挥手**：服务器发送FIN=1, ACK=1, seq=w, ack=u+1。
4. **第四次挥手**：客户端发送ACK=1, seq=u+1, ack=w+1。

## TCP 状态解读
- **CLOSED**：关闭状态。
- **LISTEN**：服务器处于监听状态，等待客户端连接。
- **SYN-RCVD**：服务器接收到SYN报文，等待客户端的ACK报文。
- **SYN-SENT**：客户端已发送SYN报文，等待服务器的第二次握手。
- **ESTABLISHED**：连接已经建立。
- **FIN-WAIT-1**：客户端发送FIN报文，等待服务器的ACK。
- **FIN-WAIT-2**：客户端收到服务器的ACK，等待服务器的FIN报文。
- **TIME-WAIT**：客户端收到服务器的FIN报文，发送ACK后等待2MSL。
- **CLOSE-WAIT**：服务器收到客户端的FIN报文，发送ACK后等待关闭。
- **LAST-ACK**：服务器发送FIN报文，等待客户端的ACK。
- **CLOSING**：双方几乎同时关闭连接。

## TCP 疑问
- **为什么建立连接要进行3次握手？**：防止服务器端一直等待，浪费资源。
- **第3次握手失败了会怎么处理？**：服务器会重新发送SYN+ACK包，若多次重发仍无响应，则发送RST包强制关闭连接。
- **为什么释放连接要进行4次挥手？**：TCP是全双工模式，双方需要分别确认关闭连接。

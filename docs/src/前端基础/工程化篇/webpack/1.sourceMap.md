## 什么是sourceMap

> 简单说，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。
>
> 有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。

## **如何生成Source map**

1. 可以使用Google的[Closure编译器](https://developers.google.com/closure/compiler/)。命令如下：

```cmd
java -jar compiler.jar \
　　　　--js script.js \
　　　　--create_source_map ./script-min.js.map \
　　　　--source_map_format=V3 \
　　　　--js_output_file script-min.js
```

2. webpack的[devTool选项](https://www.webpackjs.com/configuration/devtool/)，此选项控制是否生成，以及如何生成 source map。

## sourceMap文件的结构

```js
{
    version : 3, // Source map的版本，目前为3。
    file: "out.js", // 转换后的文件名。
    sourceRoot : "", // 转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。
    sources: ["foo.js", "bar.js"], // 转换前的文件。该项是一个数组，表示可能存在多个文件合并。
    names: ["src", "maps", "are", "fun"], // 转换前的所有变量名和属性名。
    mappings: "AAgBC,SAAQ,CAAEA" // 记录位置信息的字符串
}
```

## mappings属性解释

- 关键就是map文件的mappings属性。这是一个很长的字符串，它分成三层。

| 对应                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| 第一层是**行对应**   | 以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。 |
| 第二层是**位置对应** | 以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。 |
| 第三层是**位置转换** | 以[VLQ编码](https://en.wikipedia.org/wiki/Variable-length_quantity)表示，代表该位置对应的转换前的源码位置。 |

举例来说，假定mappings属性的内容如下：

> mappings:"AAAAA,BBBBB;CCCCC"

就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。

## 位置对应的原理

每个位置使用五位，表示五个字段。从左边算起，
| 对应   | 含义                                        |
| ------ | ------------------------------------------- |
| 第一位 | 表示这个位置在（转换后的代码的）的第几列。  |
| 第二位 | 表示这个位置属于sources属性中的哪一个文件。 |
| 第三位 | 表示这个位置属于转换前代码的第几行。        |
| 第四位 | 表示这个位置属于转换前代码的第几列。        |
| 第五位 | 表示这个位置属于names属性中的哪一个变量。   |

有几点需要说明。首先，所有的值都是以0作为基数的。其次，第五位不是必需的，如果该位置没有对应names属性中的变量，可以省略第五位。再次，每一位都采用VLQ编码表示；由于VLQ编码是变长的，所以每一位可以由多个字符构成。

如果某个位置是AAAAA，由于A在VLQ编码中表示0，因此这个位置的五个位实际上都是0。它的意思是，该位置在转换后代码的第0列，对应sources属性中第0个文件，属于转换前代码的第0行第0列，对应names属性中的第0个变量。